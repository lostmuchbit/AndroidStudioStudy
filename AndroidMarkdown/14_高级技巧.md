# 高级技巧

## 全局获取Context的技巧

在很多地方我们都需要Context才能使用一些函数

**比如**
在12章里我们编写的ShowToast()函数中Toast.make()就需要一个Context，在之前我们是通过要求调用者传入一个Context的参数，但是**ShowToast()能不能自己获得Context或者是让Context在项目的任何地方都能获取到？**
我们可以定制一个自己的Application类，以便于管理程序内一些全局的状态信息
```kotlin
class MyApplication:Application() {
    companion object{
        lateinit var context: Context
    }

    override fun onCreate() {
        super.onCreate()
        context=applicationContext/获取程序的Context
    }
}
```
```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding= ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        binding.button.setOnClickListener {
            "点击了测试".showToast()
        }
    }
}
```
```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    ···>
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/button"
        android:text="测试"/>

</LinearLayout>
```
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.bo.a1_context">

    <!--android:name=".MyApplication"这个是告知程序启动的时候要初始化MyApplication类-->
    <application
        android:name=".MyApplication"
        ···>
    ···
</manifest>
```

## 使用Intent传递对象

我们会发现Intent中只能添加一些简单的数据类型，**那么想要添加对象怎么办？**

### Serializable方式传递对象
Serializable就是序列化的意思，表示将一个对象转换成可储存或者可传输的状态.序列化后的对象可以在网络上传输，也可以存储到本地，序列化的方法就是**让一个类去实现Serializable接口**

**MainActivity传对象到FirstActivity中**
```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding= ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        val person=Person()
        person.name="Tome"
        person.age=21
        binding.button.setOnClickListener {
            "点击了测试".showToast()
            Thread.sleep(5000)
            var intent= Intent(this,FirstActivity::class.java)
            intent.putExtra("person_data",person)
            startActivity(intent)
        }
    }
}
```
```kotlin
data class Person(var name:String="",var age:Int=0) : Serializable{
}
```
```kotlin
class FirstActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_first)

        val person=intent.getSerializableExtra("person_data") as Person
        //虽然这里的person和MainActivity中的person的数据完全一样，但是是两个不同的对象,就像是克隆人和本体一样
        Log.d("FirstActivity","person is ${person.toString()}")
    }
}
```

### Parcelable方式
Parcelable方式是会把对象进行序列化，它会将一个完整的对象分解成Intent支持的数据类型，从而传递对象
```kotlin
data class Person(var name:String="",var age:Int=0):Parcelable{//实现Parcelable接口

    override fun describeContents(): Int {//
        return 0;//序列化返回0就完事了
    }

    override fun writeToParcel(parcel: Parcel?, flags: Int) {
        parcel?.writeString(name)//把Person中的字段写到parcel中
        parcel?.writeInt(age)
    }

    companion object CREATOR:Parcelable.Creator<Person>{
        override fun createFromParcel(parcel: Parcel?): Person {
            //从parcel中把person的各个字段读出来，从parcel读出来的顺序要和写进去的顺序一样
            val person=Person()
            person.name=parcel?.readString()?:""
            person.age=parcel?.readInt()?:0
            return person
        }

        override fun newArray(size: Int): Array<Person?> {
            return arrayOfNulls(size)//创建一个数组来存放实际对象
        }
    }
}
```
```kotlin
从MainActivity传入的时候没有区别
```
```kotlin
class FirstActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        ···
        val person=intent.getParcelableExtra<Person>("person_data") as Person
        //虽然这里的person和MainActivity中的person的数据完全一样，但是是两个不同的对象,就像是克隆人和本体一样
        Log.d("FirstActivity","person is ${person.toString()}")
    }
}
```

**这种写法太麻烦，其实一个注解就可以了**
**导包**
```kotlin
plugins {
    ···
    id 'kotlin-parcelize'
}
```
```kotlin
@Parcelize
data class Person(var name:String="",var age:Int=0):Parcelable {//实现Parcelable接口
}
这种写法要把所有字段都放在主构造函数中
```

## 定制自己的日志工具
我们需要只在程序的开发阶段打印日志，程序上线就把日志屏蔽掉，避免无用消耗用户性能.
```kotlin
object LogUtil { 
    private const val VERBOSE=1
    private const val DEBUG=2
    private const val INFO=3
    private const val WARN=4
    private const val ERROR=5
    
    private const val level= VERBOSE
    
    fun v(tag:String,msg:String){
        if(level<= VERBOSE)
            Log.v(tag,msg)
    }
    fun d(tag:String,msg:String){
        if(level<= DEBUG)
            Log.d(tag,msg)
    }
    fun i(tag:String,msg:String){
        if(level<= INFO)
            Log.i(tag,msg)
    }
    fun w(tag:String,msg:String){
        if(level<= WARN)
            Log.w(tag,msg)
    }
    fun e(tag:String,msg:String){
        if(level<= ERROR)
            Log.e(tag,msg)
    }
}
```
所以上线之后只需要把level调整到ERROR就可以了，日志只会报告程序错误

## 调整Android程序

## 深色主题
Android10.0时代Google引入了深色主题(夜间模式就可以使用了)